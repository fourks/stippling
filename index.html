<!DOCTYPE html>
<html>
<head>
	<title>Stippling</title>
	<script type="text/javascript" src="sylvester.js"></script>
	<script type="text/javascript" src="glUtils.js"></script>
	<script type="text/javascript" src="webgl-utils.js"></script>
	<script type="text/javascript" src="voronoi.js"></script>
	<script type="text/javascript" src="stippling.js"></script>

	<script id="shader-fs" type="x-shader/x-fragment">
		#ifdef GL_ES
			precision highp float;
		#endif
		varying vec4 vColor;

		void main(void) {
			gl_FragColor = vColor;
		}
	</script>

	<script id="shader-vs" type="x-shader/x-vertex">
		attribute vec3 aVertexPosition;
		attribute vec4 aVertexColor;

		uniform mat4 uMVMatrix;
		uniform mat4 uPMatrix;

		varying vec4 vColor;

		void main(void) {
			gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0);
			vColor = aVertexColor;
		}
	</script>

	<script type="text/javascript">
	/* WebGL boilerplate code */
		function getShader(gl, id) {
			var shaderScript = document.getElementById(id);
			if (!shaderScript) {
				return null;
			}

			var str = "";
			var k = shaderScript.firstChild;
			while (k) {
				if (k.nodeType == 3) {
					str += k.textContent;
				}
				k = k.nextSibling;
			}

			var shader;
			if (shaderScript.type == "x-shader/x-fragment") {
				shader = gl.createShader(gl.FRAGMENT_SHADER);
			}
			else if (shaderScript.type == "x-shader/x-vertex") {
				shader = gl.createShader(gl.VERTEX_SHADER);
			}
			else {
				return null;
			}

			gl.shaderSource(shader, str);
			gl.compileShader(shader);

			if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
				alert(gl.getShaderInfoLog(shader));
				return null;
			}

			return shader;
		}

		var mvMatrix;
		function loadIdentity() { mvMatrix = Matrix.I(4); }
		function multMatrix(m) { mvMatrix = mvMatrix.x(m); }
		function mvTranslate(v) {
			var m = Matrix.Translation($V([v[0], v[1], v[2]])).ensure4x4();
			multMatrix(m);
		}
		var pMatrix;
		function perspective(fovy, aspect, znear, zfar) {
			pMatrix = makePerspective(fovy, aspect, znear, zfar);
		}

		function ortho(left, right, bottom, top, znear, zfar) {
			pMatrix = makeOrtho(left, right, bottom, top, znear, zfar);
		}

		function setMatrixUniforms() {
			gl.uniformMatrix4fv(shaderProgram.pMatrixUniform, false, new Float32Array(pMatrix.flatten()));
			gl.uniformMatrix4fv(shaderProgram.mvMatrixUniform, false, new Float32Array(mvMatrix.flatten()));
		}

		var gl;
		var gl2d;	// For drawing points
		function initGL(canvas) {
			try {
				gl = canvas.getContext("experimental-webgl");
				gl.viewportWidth = canvas.width;
				gl.viewportHeight = canvas.height;
			}
			catch(e) {
				if (!gl) { alert("Could not initialize WebGL"); }
			}
		}

		var shaderProgram;
		function initShaders() {
			var fragmentShader 	= getShader(gl, "shader-fs");
			var vertexShader	= getShader(gl, "shader-vs");

			shaderProgram = gl.createProgram();
			gl.attachShader(shaderProgram, vertexShader);
			gl.attachShader(shaderProgram, fragmentShader);
			gl.linkProgram(shaderProgram);

			if (!gl.getProgramParameter(shaderProgram, gl.LINK_STATUS)) {
				alert("Could not initialize shaders");
			} 

			gl.useProgram(shaderProgram);

			shaderProgram.vertexPositionAttribute = gl.getAttribLocation(shaderProgram, "aVertexPosition");
			gl.enableVertexAttribArray(shaderProgram.vertexPositionAttribute);

			shaderProgram.vertexColorAttribute = gl.getAttribLocation(shaderProgram, "aVertexColor");
			gl.enableVertexAttribArray(shaderProgram.vertexColorAttribute);

			shaderProgram.pMatrixUniform = gl.getUniformLocation(shaderProgram, "uPMatrix");
			shaderProgram.mvMatrixUniform = gl.getUniformLocation(shaderProgram, "uMVMatrix");
		}

		var vor;
		/**
		 * Sets up everything at startup
		 */
		function pageStart() {
			var canvas = $("main-canvas");
			canvas.addEventListener("mousedown", startDown, false);
			canvas.addEventListener("mousemove", canvasMouseMove, false);
			canvas.addEventListener("mouseup", canvasClick, false);
			initGL(canvas);

			canvas = $("2d-canvas");
			canvas.addEventListener("mousedown", startDown, false);
			canvas.addEventListener("mousemove", canvasMouseMove, false);
			canvas.addEventListener("mouseup", canvasClick, false);
			canvas.style.zIndex = "100";
			gl2d = canvas.getContext("2d");

			initShaders();

			var numStipples = $("numStipples").value;
			var displayVor = $("displayVor").checked;
			
			vor = new Voronoi(gl, gl2d, shaderProgram);
			vor.init(numStipples, displayVor);
			vor.draw();

			tick();
		}

		function buttonClick() {
			var numStipples = $("numStipples").value;
			var displayVor = $("displayVor").checked;
			vor.reset(numStipples, displayVor);
		}

		/**
		 * Convenience function to get the cursors position
		 */
		function getCursorPosition(e) {
			var x, y;
			if (e.pageX || e.pageY) {
				x = e.pageX;
				y = e.pageY;
			}
			else {
				x = e.clientX + document.body.scrollLeft + document.documentElement.scrollLeft;
				y = e.clientY + document.body.scrollTop + document.documentElement.scrollTop;
			}
			x -= document.getElementById("main-canvas").offsetLeft;
			y -= document.getElementById("main-canvas").offsetTop;

			return [x, y];
		}

		// Mouse handlers
		var mouseIsDown = false;
		var curColor = null;
		var mousePosition = null;
		var canvasClicked = false;
		/**
		 * Event handler when the mouse is pressed own
		 */
		function startDown(e) {
			mouseIsDown = true;
			mousePosition = getCursorPosition(e);
		}

		/**
		 * Event handler when the mouse is moved over the canvas
		 */
		function canvasMouseMove(e) {
			if (!mouseIsDown) return;		// Do nothing if not pressing down on mouse
			mousePosition = getCursorPosition(e);
		}

		/**
		 * Event handler when a mouse click occurs
		 * Adds a new point to the voronoi diagram
		 */
		function canvasClick(e) {
			mouseIsDown = false;
			canvasClicked = !canvasClicked;
			return;
		}

		/**
		 * This function is called every animation frame
		 */
		function tick() {
			requestAnimFrame(tick);

			// TODO: Use this if necessary
			if (canvasClicked) {
				vor.moveToCentroid();
			}
		}
	</script>
</head>

<body onload="pageStart();">
	<canvas id="2d-canvas" style="border: none; position: absolute;" width="900" height="550"></canvas>
	<canvas id="main-canvas" style="border: none; position: absolute;" width="900" height="550"></canvas>
	
	<div style="margin-left: 900px; padding: 15px;">
		<form>
		# of stipple points: <input type="number" id="numStipples" min="1" max="20000" value="100" required><br>
		Display Voronoi: <input type="checkbox" id="displayVor" checked="true">Test</input> <br><br>
		</form>
		
		<button type="button" onclick="buttonClick();">Submit</button>
	</div>
</body>
</html>