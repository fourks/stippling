<!DOCTYPE html>
<html>
<head>
	<title>Stippling</title>

	<style type="text/css">
		img {
			filter: url(filters.svg#grayscale); /* Firefox 3.5+ */
			filter: gray;	/* IE6-9 */
			-webkit-filter: grayscale(1); /* Google Chrome & Safari 6+*/
		}
	</style>

	<script type="text/javascript" src="sylvester.js"></script>
	<script type="text/javascript" src="glUtils.js"></script>
	<script type="text/javascript" src="webgl-utils.js"></script>
	<script type="text/javascript" src="voronoi.js"></script>
	<script type="text/javascript" src="stippling.js"></script>

	<script id="shader-fs" type="x-shader/x-fragment">
		#ifdef GL_ES
			precision highp float;
		#endif
		varying vec4 vColor;

		void main(void) {
			gl_FragColor = vColor;
		}
	</script>

	<script id="shader-vs" type="x-shader/x-vertex">
		attribute vec3 aVertexPosition;
		attribute vec4 aVertexColor;

		uniform mat4 uMVMatrix;
		uniform mat4 uPMatrix;

		varying vec4 vColor;

		void main(void) {
			gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0);
			vColor = aVertexColor;
		}
	</script>

	<script type="text/javascript">
	/* WebGL boilerplate code */
		function getShader(gl, id) {
			var shaderScript = document.getElementById(id);
			if (!shaderScript) {
				return null;
			}

			var str = "";
			var k = shaderScript.firstChild;
			while (k) {
				if (k.nodeType == 3) {
					str += k.textContent;
				}
				k = k.nextSibling;
			}

			var shader;
			if (shaderScript.type == "x-shader/x-fragment") {
				shader = gl.createShader(gl.FRAGMENT_SHADER);
			}
			else if (shaderScript.type == "x-shader/x-vertex") {
				shader = gl.createShader(gl.VERTEX_SHADER);
			}
			else {
				return null;
			}

			gl.shaderSource(shader, str);
			gl.compileShader(shader);

			if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
				alert(gl.getShaderInfoLog(shader));
				return null;
			}

			return shader;
		}

		var mvMatrix;
		function loadIdentity() { mvMatrix = Matrix.I(4); }
		function multMatrix(m) { mvMatrix = mvMatrix.x(m); }
		function mvTranslate(v) {
			var m = Matrix.Translation($V([v[0], v[1], v[2]])).ensure4x4();
			multMatrix(m);
		}
		var pMatrix;
		function perspective(fovy, aspect, znear, zfar) {
			pMatrix = makePerspective(fovy, aspect, znear, zfar);
		}

		function ortho(left, right, bottom, top, znear, zfar) {
			pMatrix = makeOrtho(left, right, bottom, top, znear, zfar);
		}

		function setMatrixUniforms() {
			gl.uniformMatrix4fv(shaderProgram.pMatrixUniform, false, new Float32Array(pMatrix.flatten()));
			gl.uniformMatrix4fv(shaderProgram.mvMatrixUniform, false, new Float32Array(mvMatrix.flatten()));
		}

		var gl;
		var gl2d;	// For drawing points
		function initGL(canvas) {
			try {
				gl = canvas.getContext("experimental-webgl");
			}
			catch(e) {
				if (!gl) { alert("Could not initialize WebGL"); }
			}
		}

		var shaderProgram;
		function initShaders() {
			var fragmentShader 	= getShader(gl, "shader-fs");
			var vertexShader	= getShader(gl, "shader-vs");

			shaderProgram = gl.createProgram();
			gl.attachShader(shaderProgram, vertexShader);
			gl.attachShader(shaderProgram, fragmentShader);
			gl.linkProgram(shaderProgram);

			if (!gl.getProgramParameter(shaderProgram, gl.LINK_STATUS)) {
				alert("Could not initialize shaders");
			} 

			gl.useProgram(shaderProgram);

			shaderProgram.vertexPositionAttribute = gl.getAttribLocation(shaderProgram, "aVertexPosition");
			gl.enableVertexAttribArray(shaderProgram.vertexPositionAttribute);

			shaderProgram.vertexColorAttribute = gl.getAttribLocation(shaderProgram, "aVertexColor");
			gl.enableVertexAttribArray(shaderProgram.vertexColorAttribute);

			shaderProgram.pMatrixUniform = gl.getUniformLocation(shaderProgram, "uPMatrix");
			shaderProgram.mvMatrixUniform = gl.getUniformLocation(shaderProgram, "uMVMatrix");
		}

		var vor;
		/**
		 * Sets up everything at startup
		 */
		function pageStart() {
			var canvas = $("main-canvas");
			canvas.width = canvas.clientWidth;
			canvas.height = canvas.clientHeight;
			canvas.addEventListener("mousedown", startDown, false);
			canvas.addEventListener("mousemove", canvasMouseMove, false);
			canvas.addEventListener("mouseup", canvasClick, false);
			initGL(canvas);

			canvas = $("2d-canvas");
			canvas.width = canvas.clientWidth;
			canvas.height = canvas.clientHeight;
			canvas.addEventListener("mousedown", startDown, false);
			canvas.addEventListener("mousemove", canvasMouseMove, false);
			canvas.addEventListener("mouseup", canvasClick, false);
			canvas.style.zIndex = "100";
			gl2d = canvas.getContext("2d");

			initShaders();

			var numStipples = $("numStipples").value;
			var displayVor = $("displayVor").checked;
			
			vor = new Voronoi(gl, gl2d, shaderProgram);

			tick();
		}

		function start() {
			var numStipples = $("numStipples").value;
			var stippleSize = $("stippleSize").value;
			var displayVor = $("displayVor").checked;
			vor.start(numStipples, stippleSize, displayVor);
			$("status").innerHTML = "Running...";
			$("start").disabled = true;
			$("stop").disabled = false;
			$("save").disabled = false;
		}

		function stop() {
			vor.stop();
			$("start").disabled = false;
			$("stop").disabled = true;
		}

		function save() {
			var canvas = $("2d-canvas");
			var img = canvas.toDataURL("image/png");
			window.open(img, "Output", "resizable=0, location=0, width=" + (canvas.width + 50) + ", height=" + (canvas.height + 50));
		}

		function stippleSizeChanged() {
			vor.setStippleSize($("stippleSize").value);
			vor.draw();
		}

		function stippleColorChanged() {
			vor.setStippleColor($("stippleColor").value);
			vor.draw();
		}

		function displayVorClicked() {
			vor.setDisplayVor($("displayVor").checked);
			vor.draw();
		}

		function displayImageClicked() {
			if ($("displayImage").checked) {
				$("theImage").style.visibility = "visible";
			}
			else {
				$("theImage").style.visibility = "hidden";
			}
		}

		var originalCanvasWidth = 900;
		var originalCanvasHeight = 550;
		function onFileSelected(event) {
			// Reset canvas size
			setCanvasSize(originalCanvasWidth, originalCanvasHeight);
			var selectedFile = event.target.files[0];
			var reader = new FileReader();

			var img = $("theImage");
			img.title = selectedFile.name;

			reader.onload = function(event) {
				img.onload = function() {
					vor.setImage(img);
					setCanvasSize(img.width, img.height);
					$("start").disabled = false;
				}
				img.src = event.target.result;
			};

			reader.readAsDataURL(selectedFile);
		}

		function setCanvasSize(width, height) {
			$("canvases").style.width = "" + width + "px";
			$("canvases").style.height = "" + height + "px";
			var canvas = $("main-canvas");
			canvas.width = canvas.clientWidth;
			canvas.height = canvas.clientHeight;
			canvas = $("2d-canvas");
			canvas.width = canvas.clientWidth;
			canvas.height = canvas.clientHeight;
		}

		/**
		 * Convenience function to get the cursors position
		 */
		function getCursorPosition(e) {
			var x, y;
			if (e.pageX || e.pageY) {
				x = e.pageX;
				y = e.pageY;
			}
			else {
				x = e.clientX + document.body.scrollLeft + document.documentElement.scrollLeft;
				y = e.clientY + document.body.scrollTop + document.documentElement.scrollTop;
			}
			x -= document.getElementById("main-canvas").offsetLeft;
			y -= document.getElementById("main-canvas").offsetTop;

			return [x, y];
		}

		// Mouse handlers
		var mouseIsDown = false;
		var curColor = null;
		var mousePosition = null;
		var canvasClicked = false;
		/**
		 * Event handler when the mouse is pressed own
		 */
		function startDown(e) {
			mouseIsDown = true;
			mousePosition = getCursorPosition(e);
		}

		/**
		 * Event handler when the mouse is moved over the canvas
		 */
		function canvasMouseMove(e) {
			if (!mouseIsDown) return;		// Do nothing if not pressing down on mouse
			mousePosition = getCursorPosition(e);
		}

		/**
		 * Event handler when a mouse click occurs
		 * Adds a new point to the voronoi diagram
		 */
		function canvasClick(e) {
			mouseIsDown = false;
			canvasClicked = true;
			return;
		}

		/**
		 * This function is called every animation frame
		 */
		function tick() {
			requestAnimFrame(tick);

			if (vor.isMakingCentroidal()) {
				vor.moveToCentroid();
			}
			else {
				$("status").innerHTML = "Stopped...";
				$("start").disabled = false;
			}
		}
	</script>
</head>

<body onload="pageStart();">
	<div id="canvases" style="border-style: solid; border-width: 1px; position: absolute; width: 900px; height: 550px;">
		<canvas id="2d-canvas" style="position: absolute; width: 100%; height: 100%;"></canvas>
		<canvas id="main-canvas" style="position: absolute; width: 100%; height: 100%;"></canvas>
		<img id="theImage" style="max-width: 100%; max-height: 100%;"/>
	</div>
	
	<div style="margin-left: 900px; padding: 15px;">
		<form>
		# of stipple points: <input type="number" id="numStipples" min="1" max="20000" value="100" required><br>
		Stipple size: <input type="number" id="stippleSize" min="0.1" max="2.5" value="2.5" step="0.1" onchange="stippleSizeChanged();" required /><br>
		Stipple color: <input type="color" id="stippleColor" onchange="stippleColorChanged();" /><br>
		Display Voronoi: <input type="checkbox" id="displayVor" checked="true" onclick="displayVorClicked();" /><br>
		Display Image: <input type="checkbox" id="displayImage" checked="true" onclick="displayImageClicked();" /><br>
		<input type="file" text="Choose photo" accept="image/*" onchange="onFileSelected(event)"/>
		</form>

		<button id="start" type="button" onclick="start();" disabled>Start</button>
		<button id="stop" type="button" onclick="stop();" disabled>Stop</button>
		<button id="save" type="button" onclick="save();" disabled>Save</button>
		<div id="status">Stopped...</div>
	</div>
</body>
</html>